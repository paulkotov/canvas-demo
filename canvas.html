<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-width: 100vw;
      min-height: 100vh;
      overflow: hidden;
    }

    #canvas {
      background-color: black;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      min-height: 100vh;
      /* max-width: 100vw; */
      /* max-height: 100vh; */
    }

    .controls__container {
      position: absolute;
      z-index: 10;
    }

    .controls__form {
      height: 32px;
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      /* align-items: center; */
      gap: 8px;
    }

    .controls__form_input {
      min-width: 100px;
      font-size: medium;
    }

    .controls__form_button {
      min-width: 100px;
    }

    .controls__form_checkbox {
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 8px;
      color: #fff;
    }
  </style>
  <div class="controls__container">
    <form name="controls__form" class="controls__form">
      <input class="controls__form_input" type="number" name="branches" placeholder="branches">
      <input class="controls__form_input" type="decimal" name="spread" placeholder="spread">
      <!-- TODO: change input to rays -->
      <input class="controls__form_input" type="number" name="sides" placeholder="sides">
      <input class="controls__form_input" type="number" name="scale" placeholder="scale">
      <input class="controls__form_input" type="number" name="angle" placeholder="angle" min="0" max="180">
      <button class="controls__form_button" type="submit" name="generate">Draw</button>
      <button class="controls__form_button" type="reset" name="reset">Reset</button>

      <div class="controls__form_checkbox">
        <label for="randomInsert">Random insert</label>
        <input class="controls__form_input" type="checkbox" name="randomInsert" placeholder="size">
      </div>
      <!-- TODO: add checkbox for symmetric fractal -->
    </form>

  </div>
  <canvas id="canvas"></canvas>
  <!-- <canvas id="animated-canvas"></canvas> -->
  <script>
    const get = (obj, key, defaultValue) => {
      if (!obj) {
        return defaultValue;
      }
      if (key in obj) {
        return obj[key];
      }
      return defaultValue;
    };

    function generateId() {
      return '_' + Math.random().toString(36).substr(2, 9);
    }

    class Canvas {
      constructor(id, params = {}) {
        if (!id) {
          this.#createCanvas(params);
        } else {
          this.#getCanvas(id, params);
        }
        this.elements = [];
        this.originX = 0;
        this.originY = 0;
        this.elements = [];
      }

      #createCanvas(params) {
        const canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        canvas.width = get(params, 'width', window.innerWidth);
        canvas.height = get(params, 'height', window.innerHeight);
        this.canvas = canvas;
        this.context = canvas.getContext('2d');
      }

      #getCanvas(id, params) {
        const canvas = document.getElementById(id);
        if (!canvas) {
          this.#createCanvas(params);
        } else {
          canvas.width = get(params, 'width', window.innerWidth);
          canvas.height = get(params, 'height', window.innerHeight);
          this.canvas = canvas;
          this.context = canvas.getContext('2d');
        }
      }

      createElement(type, params) {
        let element;
        switch (type) {
          case 'line':
            element = new Line(params);
            break;
          case 'circle':
            element = new Circle(params);
            break;
          case 'arc':
            element = new Arc(params);
            break;
          default:
            throw new Error('Unsupported element type');
        }
        this.elements.push(element);
        return element;
      }

      removeElement(element) {
        this.elements = this.elements.filter(el => el !== element);
      }

      getElementById(id) {
        return this.elements.find(el => el.id === id);
      }

      appendChild(element) {
        this.elements.push(element);
        element.draw(this.context);
      }

      draw() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.elements.forEach(element => element.draw(this.context));
      }

      clear() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
    }

    class Fractal {
      context = null;
      params = {};

      constructor(canvasRef, fractalParams) {
        if (!canvasRef || !(canvasRef instanceof HTMLCanvasElement)) {
          throw Error('Error with accessing canvas');
        }
        this.width = canvasRef.width;
        this.height = canvasRef.height;

        const ctx = canvasRef.getContext('2d');
        ctx.lineWidth = 10;
        ctx.lineCap = 'round';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
        ctx.shadowOffsetX = 10;
        ctx.shadowOffsetY = 5;
        ctx.shadowBlur = 10;
        this.context = ctx;

        this.params.size = get(fractalParams, 'size', 300);
        this.params.sides = get(fractalParams, 'sides', 5);
        this.params.maxLevel = get(fractalParams, 'maxLevel', 2);
        this.params.scale = get(fractalParams, 'scale', 0.7);
        this.params.spread = get(fractalParams, 'spread', 0.5);
        this.params.branches = get(fractalParams, 'branches', 2);
        this.params.baseHue = get(fractalParams, 'baseHue', 200); // Starting hue (0-360)
      }

      #drawBranch(level) {
        // TODO: add max level to params
        if (level === undefined || level > this.params.maxLevel) {
          return;
        }
        // Calculate hue based on level (shifts color per level)
        const hueShift = (level / this.params.maxLevel) * 120; // 0 to 120 degree shift
        this.context.strokeStyle = `hsl(${this.params.baseHue + hueShift}, 100%, 50%)`;

        this.context.beginPath();
        this.context.moveTo(0, 0);
        this.context.lineTo(this.params.size, 0);
        this.context.stroke();

        for (let i = 0; i < this.params.branches; i++) {
          this.context.save();
          this.context.translate(this.params.size - (this.params.size / this.params.branches) * i, 0);
          this.context.rotate(this.params.spread);
          this.context.scale(this.params.scale, this.params.scale);
          this.#drawBranch(level + 1);
          this.context.restore();

          this.context.save();
          this.context.translate(this.params.size - (this.params.size / this.params.branches) * i, 0);
          this.context.rotate(-this.params.spread);
          this.context.scale(this.params.scale, this.params.scale);
          this.#drawBranch(level + 1);
          this.context.restore();
        }
      }

      draw(position, scale, rotate) {
        this.context.save();
        this.context.translate(
          get(position, 'x', this.width / 2),
          get(position, 'y', this.height / 2)
        );
        this.context.scale(scale || 1, scale || 1);
        this.context.rotate(rotate || 0);

        for (let i = 0; i < this.params.sides; i++) {
          this.context.rotate((Math.PI * 2) / this.params.sides);
          this.#drawBranch(0);
        }
        this.context.restore();
      }
    }

    window.addEventListener('load', function () {

      const canvas = new Canvas('canvas');
      const form = document.querySelector('form[name="controls__form"]');
      // console.log(form);
      form.addEventListener('submit', function (e) {
        e.preventDefault();
        const branchesInput = form.querySelector('input[name="branches"]');
        const spreadInput = form.querySelector('input[name="spread"]');
        const sidesInput = form.querySelector('input[name="sides"]');
        const angleInput = form.querySelector('input[name="angle"]');
        const branches = branchesInput.value;
        const spread = spreadInput.value;
        const sides = sidesInput.value;
        const randomInsertInput = form.querySelector('input[name="randomInsert"]');
        const isRandomInsert = randomInsertInput.checked;
        let points = undefined;
        // need save
        if (isRandomInsert) {
          points = {
            x: Math.random() * canvas.canvas.width,
            y: Math.random() * canvas.canvas.height
          };
        }
        let rotation = 0;
        if (angleInput.value) {
          rotation = angleInput.value * Math.PI / 180;
        }
        new Fractal(canvas.canvas, { baseHue: 60, branches, spread, sides, maxLevel: 3 }).draw(points, 1, 0.25, rotation);
      });
      form.addEventListener('reset', function (e) {
        e.preventDefault();
        // get form controls
        // const form = document.querySelector('form[name="controls__form"]');
        const branchesInput = form.querySelector('input[name="branches"]');
        const spreadInput = form.querySelector('input[name="spread"]');
        const sidesInput = form.querySelector('input[name="sides"]');
        const angleInput = form.querySelector('input[name="angle"]');
        branchesInput.value = '';
        spreadInput.value = '';
        sidesInput.value = '';
        angleInput.value = '';
        canvas.clear();
      });
      // new Fractal(canvas.canvas, { baseHue: 60 }).drawFractal({ x: 200, y: 200 }, 0.25);
      // new Fractal(canvas.canvas, { size: 150, sides: 5, maxLevel: 3, baseHue: 0 }).drawFractal(undefined, 1, 0.2);
    });

  </script>
</body>

</html>